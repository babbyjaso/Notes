- for 32 bit executables that need to be debugged
- CPU window
	- basically all the instructions for the CPU
	- Looks a lot like what you saw in Cutter
- Memory Registers
	- right window in dbg
	- shows where your memory values are
		- [[Static Analysis#^stat-mem|These here]]
- Stack
	- Bottom right window in dbg
	- shows anything that is pushed or popped in the [[Static Analysis#^stat-stack|stack]]
- Hexdump
	- bottom left
	- Not the best way to find these, but good to have
- You're gonna be using the function keys
	- F2
		- set Breakpoint
	- F7
		- Step Into
		- A method is about to be invoked, and you want to debug into the code of that method, so the next step is to go into that method and continue debugging step-by-step.
	- F8
		- Step Over
		- A method is about to be invoked, but you're not interested in debugging this particular invocation, so you want the debugger to execute that method completely as one entire step.
	- F9
		- run
		- Executes as if the OS is executing the program
	- Ctrl + F2
		- restart your program
- Starting your program
	- Hit F9, and it'll go straight to the entrypoint
		- this is where the OS will start
		- dbg is nice and sets a breakpoint right where the entry is
	- Hit F8, next set of instructions
		- this will continue as you keep hitting F8 to go to the next instruction
	- Once you hit a push, you can see it being pushed onto the stack in real time from the Stack window
	- once you hit a call, you can step over to go to the next instruction in the CPU list or step into to return the value for the call
		- either go down the list or follow the program
- If you get lost, hit restart and go back to the beginning
- Breakpoints
	- every time you try to run the program (F9), it will stop at the breakpoint
	- great place to put call instructions
	- can check all your breakpoints under the breakpoint tab
- Goal: Find the most interesting instructions
	- lots of junk, but we gotta pan for gold
	- when you find the gold, set a breakpoint, step in and find out what it's doing.
- Find out where it's doing things
	- Start over (Ctrl+F2), go to the start (F9), go down the list (F8) until something takes a bit to process
		- def put a breakpoint where this program hangs
			- Typically this is a call, because that's where things happen
	- Now, we'll follow what it did
		- Follow in Disassembler
	- Using what we've seen in static analysis we can look for what it's doing here
		- reaching out to URL
		- creating registry keys
		- deleting itself
		- etc
	- in this example, you can see the "InternetOpenW" API call
		- We follow it backwards and see that it is providing all of the required options for it
		- In this example, we do see one that has a memory location for one of the arguments for the API call: User Agent
			- Can see familiar things like we saw in Cutter
			- if you go back to the top where it starts pushing the arguments and F7 your way down, you can watch it be pushed onto the stack
			- ![[Screenshot_20240926_144814.png]]
		- going down we also see an example of testing against itself.
			- It downloaded a file, so it set `eax` to 00000000
				- it did not fail
				- [[Static Analysis#^stat-mem]]
			- now it will set a Zero Flag `ZF` after `test`ing the [bitwise AND](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND) function of `eax` against `eax` 
				- 0 and 0 is 0, so we set the `ZF` 
		- After, we see a `jne`
			- "If this flag is not set, we're going somewhere else"
			- you can see where that is in the memory
		- But...what if we make it go anyway?
			- we can edit the `ZF` to not be set and watch it jump, despite the connection being successful
			- you can use this to get around [[Dynamic Analysis#^anti-analysis|anti analysis techniques]] 