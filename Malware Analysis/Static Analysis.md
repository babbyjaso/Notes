- Basic analysis ^static-bas
	- Using tools to look at the malware without executing it
		- get hashes
		- look at any [[PEview#^win-api|Windows API calls]]
		- look at any [[Strings]] in the malware
		- look at the size of the malware to see if it's [[Packed Malware|packed]] or not
	- tools to do this:
		- [[Strings]]
		- [[PEview]]
		- [[PEstudio]]
		- [[FLOSS]]
- Advanced analysis ^static-adv
	- Uses
		- Decompilers
		- Disassemblers
	- Tools:
		- [[Cutter]]
	- Looking at the [[Assembly|assembly instructions]] of the malware (ASM)
		- Human readable CPU instruction set
		- CPU deals in binary, ASM is the pattern of binary put to somewhat human readable language
	- Compiler takes the human stuff (`print(hello world)`) and turns it into binary
	- Several things have to be present for a binary to execute:
		- CPU instructions
			- Arithmetic instructions
				- `sub`, etc.
			- Data movement instructions
				- `mov`, `jnz`, `jmp`, `jne`, etc
			- Control flow instructions
				- `push`, `pop`, `call`, `ret` etc.
					- [[Cutter]] is super nice and will show us what/where is being manipulated
		- Memory registers ^stat-mem
			- holds and handles data at runtime
				- ex: reading a tape
			- `eax`, `edx`, `ebx`, `esp`, `ebp`, etc.
		- Stack ^stat-stack
			- stack grows downward
			- finds a place in memory and starts from zero and moves down
			- LIFO
				- Last In First Out
				- reads from the bottom up
	- Process Injection
		- program that will take a legitimate process and inject some kind of code into it
			- example here takes an argument in the code
				- in this case shell codea
			- passes this argument into a process
				- werfault.exe
			- then tells it to write the code to memory inside of the process
				- making room in the process memory for the code
			- then opens the remote thread
				- legit werfault.exe opened, but it's got a shell inside of it
		- This does start the process as the child process of the malicious program
			- after the `CreateRemoteThread` it becomes its own parent
			- lots of EDR solutions watch for `CreateRemoteThread` so this is also rookie hours
	- Extracting shell code
		- most of the time we have to extract shellcode from memory
			- memory is typically where shellcode lives
			- allows attacks like [[Memory#^stack-overflow|Stack Buffer Overflow]] 
		- For this example, we already have the bytes, we see them from a previous example
		- but what we can do with a debugger is find the injecting process and carve out the bytes from the created process
		- First, we gotta find the process
			- we're looking for the last function to return something into `eax`
			- you can find the return of the program from the entrypoint
		- work backwards to find the process
			- find your `mov eax, value` and follow the steps
			- you can rename your functions in [[Cutter]]
		- once you find the function, copy the memory location and then go to [[x*dbg]]
			- ctrl + g: search for a memory location
			- create a breakpoint
			- run the program until you get to that breakpoint for the code
			- then we analyze the arguments for that call, then look for the bytes
				- right click > follow in dump
			- you can see all the bytes in memory and can pull those by saving to a file
		- after this, you can run through it using [[scdbg]] to extract the [[PEview#^win-api|WinAPI]] calls
	- Decoding Powershell
		- typically powershells will invoke expressions or `iex`
		- if you remove that, you've essentially defanged the script
		- assign that script to a variable in windows
			- ex: `$variable`
		- write it out to the host with `write-host` and the malware will just output what it's doing
	- HTML Applications (HTA)
		- portable HTML site that can be sent
			- company survey
			- presentation
			- etc.
		- This is treated like a trusted document, because it's saved locally
			- it can run HTML/CSS code, which is the scary part
		- Like any other static malware, we can analyze what the script is doing by googling functions
		- This can start a powershell or VBS to open a shell