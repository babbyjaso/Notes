- Binary talks to CPU
- We assign binary to sets of 8 into a hex digit, called a byte
	- 4 x 4
	- ex: 10100101
		- 1010 = A
		- 0101 = 5
		- Hex number: A5
			- written `0xA5`
- among these hex numbers are opcodes and operands
- # Opcodes
	- Numbers that correspond to instructions performed by the CPU
	- Not an Operand, which is what the opcode is performing the instruction on
	- ex: `040000:    b8 5f 00 00 00    mov eax, 0x5f`
		- This instruction is `mov eax, 0x5f`
		- `040000:` is where the instruction is located
		- `b8` is the instruction `mov eax`
		- `5f 00 00 00` is the operand `0x5f`
			- because of [endianness](https://en.wikipedia.org/wiki/Endianness) it has multiple bytes
			- This is the big-endianness notation
				- [most significant byte](https://en.wikipedia.org/wiki/Bit_numbering#Most-_vs_least-significant_bit_first) at the smallest memory address
				- reads left to right
			- little-endianess notation: `00 00 00 5f`
				- Flip of BE
				- dominant ordering for x86 architectures
	- ![[Pasted image 20240930195510.png]]
	- Three types of operands ^operands
		- ## Immediate operands
			- constants and/or fixed values
			- eg: `0x5f`
		- ## Registers
			- eg: `eax`
			- where immediate operands are stored
			- these are in the CPU unless otherwise dictated (Memory Registers)
			- 32 bits in x86 architecture
				- registers will start with an "E"
			- 64 bits in x64 architecture\
				- Registers will start with an "R"
			- ![[Pasted image 20241005160552.png]]
				- `rax` is a 64 bit register
					- bytes 0-7
					- `0x0123456789abcdef`
				- half of which is `eax`
					- bytes 4-7
					- `0x89abcdef`
				- half of which is `ax`
					- bytes 6-7
					- `0xcdef`
				- half of which is `ah` and `al`
					- byte 6 and 7
					- `0xcd` and `0xef`
			- `eax`/`rax`
				- Accumulator Register
				- often results of arithmetic operations
			- `ebx`/`rbx`
				- Base Register
				- often used to store the Base address for referencing
			- `ecx`/`rcx`
				- Counter Register
				- often used to count operations (loops, etc.)
			- `edx`/`rdx`
				- Data Register
				- often used for [[Assembly#^asm-arith|`mul`/`div`]] operations
			- `esp`/`rsp` ^esp-rsp
				- Stack Pointer
				- points to the top of the stack
				- works with Stack Segment
				- only 32-bits or larger
			- `ebp`/`rbp` ^ebp-rbp
				- Base Pointer
				- address where the current program stack tracks local variables and arguments
					- access parameters passed by the stack
				- also works with the Stack Segment
				- only in 32-bits or larger
			- `esi`/`rsi`
				- Source Index
				- used for string operations
				- used with Data Segment register
			- `edi`/`rdi`
				- Destination Index
				- used for string operations
				- used with Extra Segment
			- `r8-r15`
				- only in 64-bit architectures
				- general purpose registers
			- #### Segment Registers
				- 16-bit registers that convert flat memory into different segments for easier addressing
				- More pointers than anything
				- Code Segment (CS)
					- points to a code section in memory
				- Data Segment (DS)
					- points to the program's data section in memory
				- Stack Segment (SS)
					- points to the program's Stack in memory
		- ## Memory operands
			- denoted by square brackets
			- references memory locations
			- eg: `[eax]`
				- the value in `eax` is the memory location where the operation has to be performed
- # Instructions
	- tells the CPU what operation to perform
	- uses all three of the [[Assembly#^operands|operand]] types
	- stores the results in memory
	- ## General instructions
		- `mov`
			- `mov destination, source`
			- ex: `mov eax, 0x5f`
				- move `0x5f` to the register `eax`
			- ex: `mov ebx, eax`
				- move the value stored in `eax` to `ebx`
			- ex: `mov eax, [0x5fc53e]`
				- move the value stored in memory register `[0x5fc53e]` to the register `eax`
			- ex: `mov eax, [ebp+4]`
				- adds an offset of 4 bytes to the register `ebp` then moves that to `eax`
		- `lea`
			- Load Effective Address
			- `lea destination, source`
			- `mov` moves the data, `lea` moves the address of the source to the location
			- ex: `lea eax, [ebp+4]`
				- We are moving the value of `ebp` by 4 bytes, then moving that to `eax`
				- vs the same thing as a `mov` which would just be value in `ebp+4`
				- save the result, not the value
			- often used for arithmetic operations on a register then saving that to another register in one fell swoop
		- `nop`
			- No OPeration
			- 0
			- zilch
			- nothing
			- eats CPU cycles
			- used by malware to redirect execution to the shellcode
				- pads up the execution so it doesn't start at the middle
	- ## Shift instructions
		- SHift Right: `shr`
		- SHift Left: `shl`
		- `shl destination, count`
			- shifts the bits in the `destinaton` operand by `count`
			- bits shifted out are replaced with 0s
		- ex: `shl eax, 1`
			- assuming `eax` = 00000010
			- it becomes 00000100
		- ex: `shr eax, 1`\
			- `eax` = 00000101
			- This will set the Carry Flag (CF)
				- fills the last bit overflowing the destination
			- result = 00000010 with the CF = 1
		- used in place of some multiplication
			- `shr eax, 1` where `eax` = 00000010 get the same result as dividing `eax` by 2
	- ## Rotate instructions
		- ROtate Right: `ror`
		- ROtate Left: `rol`
		- instead of shifting the bytes, we cycle them
		- `ror destination, count`
		- ex: `ror al, 1`
			- where `al` = 10101010
			- will give us 01010101
		- ![[Pasted image 20241001174628.png]]
	- ## Arithmetic instructions ^asm-arith
		- `add`
			- adds
			- `add destination, value`
		- `sub`
			- subtracts
			- `sub destination, value`
			- Zero Flag is set if the result is zero
			- Carry Flag is set if the destination is smaller than the value
		- `mul`
			- Uses the `eax` and `edx` registers
			- because of this, we will have to look at the last instruction for those registers for every operation
			- `mul value`
				- stores the result in `edx`:`eax` as a 64-bit value
					- multiplying two 32-bit values can be higher than 32 bits
					- lower bits are in `eax`
					- higher bits are in `edx`
				- you can assign `value` as a register or constant
		- `div`
			- Uses the `eax` and `edx` registers
			- because of this, we will have to look at the last instruction for those registers for every operation
			- `div value`
				- stores the result in `edx`:`eax`
					- saves the result in `eax`
					- saves the remainder in `edx`
		- `inc`
			- increments the operand register by 1
			- ex: `inc eax`
		- `dec`
			- decrements the operand register by 1
			- ex: `dec eax`
	- ## Logical instructions
		- `and`
			- does a [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) operation on the operands
				- AND operation returns 1 when both inputs are 1
				- compares every bit, does an AND, result is the new bit
			- ex: `and al, 0x7c`
				- `0x7c` = `01111100`
				- if `al` equals...
					- `0xfc` (`11111100`) the output will be `01111100` or `7c`
					- `0x8c` (`10001100`) the output will be `00001100` or `0xc`
		- `or`
			- does a [bitwise OR](https://en.wikipedia.org/wiki/Bitwise_operation#OR) operation on the operands
				- OR operation returns 1 when either inputs are 1
			- ex: `or al, 0x7c`
				- `0x7c` = `01111100`
				- if `al` equals...
					- `0xfc` (`11111100`) the output will be `11111100` or `0xfc`
					- `0x8c` (`10001100`) the output will be `11111100` or `0xfc`
		- `not`
			- does a [bitwise NOT](https://en.wikipedia.org/wiki/Bitwise_operation#NOT) operation on the operand
				- inverts the bits
					- `11110000` becomes `00001111`
			- ex: `not al`
		- `xor`
			- does a [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) operation on the operands
				- XOR operation returns 1 when the inputs are opposite
			- ex: `xor al, 0x7c`
				- `0x7c` = `01111100`
				- if `al` equals...
					- `11111100` the result is `10000000` or `0x80`
					- `01111100` the result is `00000000` or `0x00`
- # [Flags](https://en.wikipedia.org/wiki/FLAGS_register) ^asm-flags
	- CPU has flags that indicate the outcome of certain operations
	- Stored in the flags register (EFLAGS)
	- either a specific condition or result of the most recent arithmetic/logical operation
	- used for conditional jumps
		- `jne`, `je`, etc.
		- #### Carry (CF)
			- sets when a carry-out or borrow is required from the [most significant bit](https://en.wikipedia.org/wiki/Bit_numbering#Most-_vs_least-significant_bit_first) in an arithemetic operation
			- Also bit-wise shifting operations
			- if the destination is smaller than the subtracted value
				- carry over the number
		- #### Parity (PF)
			- set if the [least significant byte](https://en.wikipedia.org/wiki/Bit_numbering#Most-_vs_least-significant_bit_first) of the result contains an even number of 1 bits
				- `11` in the bit
		- #### Auxiliary (AF)
			- set if a carry-out or borrow is required from bit 3 to bit 4 in an arithmetic operation
		- #### Zero (ZF)
			- Set if the result of the operation is zero
		- #### Sign (SF)
			- set if the result of the operation if negative
		- #### Overflow (OF)
			- set if there's a signed arithmetic overflow
				- two positive numbers and getting a negative result
		- #### Direction (DF)
			- determines the direction for string processing instructions
				- if DF=0, the string is processed forward
				- if DF=1, the string is processed backward
		- #### Interrupt Enable (IF)
			- if set, enable maskable hardware interrupts
		- #### Trap (TF)
			- Indicates if the process is in debugging mode
			- used by malware to identify if it's in a debugger
- # Conditionals
	- CPU gotta compare two values
	- conditional instructions does this
	- ### General
		- `test`
			- `test destination, source`
			- performs a [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND) 
			- stores the result in the destination operand
			- sets the ZF if that result is 0
			- used to check if an operand has a NULL value
				- often done by testing the operand against itself
				- if the operand is 1, it will be 1
		- `cmp`
			- compares two operands and sets the ZF or CF
			- `cmp destination, source`
			- works like a `sub` instruction
				- operands are not modified
			- ZF is set if both operands are equal
			- CF is set if `source` > `destination`
			- both CF and ZF are cleared if `source` < `destination`
	- ### Branching
		- control flow is in a straight line until it hits a branch
		- branching operations change the value of the instruction pointer and control flow
		- `jmp`
			- makes the control flow jump to a specified location
			- `jmp location`
				- `location` is an address in memory
		- conditional jumps
			- how the `if` statement is mapped out in assembly
			- decides whether to jump based on the value of the [[Assembly#^asm-flags|flags]]
			- syntax is similar to `jmp`
			- common conditional jumps:
				- `jz`
					- Jump if ZF is set
				- `jnz` 
					- Jump if ZF is not set
				- `je`
					- Jump if equal
				- `jne`
					- Jump if not equal
				- `jg`
					- Jump if destination > source
				- `jl`
					- Jump if destination < source
				- `jge`
					- Jump if Greater than or Equal to
						- destination ≥ source
				- `jle`
					- Jump if Less than or Equal to
						- destination ≤ source
				- `ja`
					- Jump if Above
				- `jb`
					- Jump if Below
				- `jae`
					- Jump if Above or Equal to
				- `jbe`
					- Jump if Below or Equal to
- # [[Memory#^mem-stack|Stack]]
	- `push`
		- `push source`
		- pushes the source onto the stack
		- value of that operand is stored at the memory location that is point to by `esp`
			- becomes the new top of the stack
		- `pusha` (PUSH All words)
			- pushes all 16-bit general purpose registers to the stack
			- ex: `ax`, `bx`, `cx`, etc.
		- `pushad` (PUSH All Double words)
			- pushes all 32-bit general purpose registers to the stack
			- ex: `eax`, `esi`, `esp`, etc.
		- when we encounter these, we're likely seeing someone manually injecting assembly instructions to save registers
	- `pop`
		- `pop destination`
		- removes whatever is on the top of the stack and puts it into the `destination`
		- increments the stack pointer (`esp`) to show the adjustment made
		- `popa` (POP All words)
			- pops the values in this order:
				- DI, SI, BP, BX, DX, CX, AX
			- `esp` adjusted to reflect the new top of the stack
		- `popad` (POP All Double words)
			- Pops the values from the top to general-purpose registers in this order:
				- EDI, ESI, EBP, EBX, EDX, ECX, EAX.
			- `esp` is adjusted to reflect the new top of the stack
	- `call`
		- perform a specific task
		- `call location`
		- usually used for APIs